---
import { siteConfig } from '@jet-w/astro-blog/config';
import type { I18nConfig } from '../config/i18n';
import { defaultI18nConfig } from '../config/i18n';
import { getLocaleFromPath, getLocaleConfig, removeBase } from '../utils/i18n';

// Custom slides styles - bundled by Astro (loaded after CDN CSS)
import '@jet-w/astro-blog/styles/slides.css';

// CSS loading order (via <link> tags in <head>):
// 1. reveal.css (core) - CDN
// 2. theme CSS - CDN (dynamic based on frontmatter)
// 3. monokai.css (code highlighting) - CDN
// 4. KaTeX CSS - CDN
// 5. slides.css (custom) - bundled by Astro (last)

export interface Props {
  title: string;
  description?: string;
  theme?: string;
  transition?: string;
  controls?: boolean;
  progress?: boolean;
  center?: boolean;
  hash?: boolean;
  slideNumber?: boolean;
  showBackButton?: boolean;
  i18nConfig?: I18nConfig;
}

const {
  title,
  description = '',
  theme = 'black',
  transition = 'slide',
  controls = true,
  progress = true,
  center = true,
  hash = true,
  slideNumber = false,
  showBackButton = true,
  i18nConfig = defaultI18nConfig,
} = Astro.props;

// Get base URL for prefixing links
const base = import.meta.env.BASE_URL;

// Remove base URL from current path for locale detection
const pathWithoutBase = removeBase(Astro.url.pathname, base);

// Get current locale (use path without base)
const currentLocale = getLocaleFromPath(pathWithoutBase, i18nConfig);
const localeConfig = getLocaleConfig(currentLocale, i18nConfig);
const localeData = localeConfig.locale;
const localeSiteConfig = localeConfig.site;

const siteTitle = localeSiteConfig.title || siteConfig.title;
const fullTitle = `${title} | ${siteTitle}`;

// Reveal.js configuration for client-side
const revealConfig = JSON.stringify({
  hash,
  controls,
  progress,
  center,
  transition,
  slideNumber,
  markdown: {
    smartypants: true,
  },
});
---

<!DOCTYPE html>
<html lang={localeData.htmlLang}>
  <head>
    <meta charset="UTF-8" />
    <meta name="description" content={description} />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" type="image/svg+xml" href={`${base}favicon.svg`} />
    <meta name="generator" content={Astro.generator} />
    <title>{fullTitle}</title>

    <!-- Open Graph -->
    <meta property="og:type" content="article" />
    <meta property="og:title" content={fullTitle} />
    <meta property="og:description" content={description} />

    <!-- Reveal.js CSS - order matters! -->
    <!-- 1. Core reveal.css (base styles) -->
    <link rel="stylesheet" href="https://unpkg.com/reveal.js@5.2.1/dist/reveal.css" />
    <!-- 2. Theme CSS (overrides core colors/fonts) -->
    <link rel="stylesheet" href={`https://unpkg.com/reveal.js@5.2.1/dist/theme/${theme}.css`} id="theme" />
    <!-- 3. Code highlighting theme -->
    <link rel="stylesheet" href="https://unpkg.com/reveal.js@5.2.1/plugin/highlight/monokai.css" />

    <!-- KaTeX for math -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" />

    <!-- Mermaid and ECharts styles for slides -->
    <style>
      .reveal .mermaid {
        background: rgba(255, 255, 255, 0.95);
        padding: 1em;
        border-radius: 8px;
      }
      .reveal .echarts-container {
        width: 100%;
        height: 400px;
        margin: 0 auto;
      }
      .reveal pre code.language-mermaid,
      .reveal pre code.language-echarts {
        display: none;
      }
    </style>
  </head>
  <body data-reveal-config={revealConfig} data-base-url={base}>
    <div class="reveal">
      <div class="slides">
        <slot />
      </div>
    </div>

    <!-- Back button (hidden in embed mode via JS) -->
    <a href="#" class="slides-back-btn" id="slides-back-btn" title="返回上一级">
      <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M19 12H5M12 19l-7-7 7-7"/>
      </svg>
    </a>

    <!-- Mermaid -->
    <script is:inline src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>

    <!-- ECharts -->
    <script is:inline src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>

    <!-- Initialize Reveal.js using ES modules -->
    <script>
      import Reveal from 'reveal.js';
      import Markdown from 'reveal.js/plugin/markdown/markdown.esm.js';
      import Highlight from 'reveal.js/plugin/highlight/highlight.esm.js';
      import Notes from 'reveal.js/plugin/notes/notes.esm.js';
      import RevealMath from 'reveal.js/plugin/math/math.esm.js';

      // Get configuration from data attributes
      const body = document.body;
      const config = JSON.parse(body.dataset.revealConfig || '{}');
      const baseUrl = body.dataset.baseUrl || '/';

      // Handle back button
      const backBtn = document.getElementById('slides-back-btn');
      if (backBtn) {
        // Check if embedded in iframe or URL contains embed=true
        const isEmbed = window.self !== window.top ||
                        window.location.search.indexOf('embed=true') !== -1;
        if (isEmbed) {
          backBtn.style.display = 'none';
        } else {
          // Set back link to parent path
          let path = window.location.pathname;
          if (path.endsWith('/')) {
            path = path.slice(0, -1);
          }
          const parentPath = path.substring(0, path.lastIndexOf('/'));
          backBtn.href = parentPath || baseUrl;
        }
      }

      // Initialize Reveal.js
      const deck = new Reveal({
        hash: config.hash,
        controls: config.controls,
        progress: config.progress,
        center: config.center,
        transition: config.transition,
        slideNumber: config.slideNumber,
        markdown: config.markdown,
        math: {
          mathjax: null,
          katex: 'https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js',
          katexScript: 'https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js',
        },
        plugins: [Markdown, Highlight, Notes, RevealMath.KaTeX]
      });

      deck.initialize().then(() => {
        // Mermaid and ECharts containers
        const mermaidContainers: Array<{container: HTMLElement, code: string, rendered: boolean}> = [];
        const echartsInstances: Array<{container: HTMLElement, option: object, chart: any, initialized: boolean}> = [];

        // Initialize Mermaid
        if (typeof (window as any).mermaid !== 'undefined') {
          const mermaid = (window as any).mermaid;
          mermaid.initialize({
            startOnLoad: false,
            theme: 'default',
            securityLevel: 'loose'
          });

          // Find all mermaid code blocks and prepare containers
          document.querySelectorAll('pre code.language-mermaid, pre code.mermaid').forEach((block, index) => {
            const code = block.textContent || '';
            const container = document.createElement('div');
            container.className = 'mermaid';
            container.id = 'mermaid-slide-' + index;
            container.setAttribute('data-mermaid-code', code);
            container.style.minHeight = '100px';

            // Replace code block
            const pre = block.parentElement;
            if (pre && pre.parentElement) {
              pre.parentElement.insertBefore(container, pre);
              pre.style.display = 'none';
            }

            mermaidContainers.push({
              container: container,
              code: code,
              rendered: false
            });
          });

          // Render visible Mermaid diagrams
          async function renderVisibleMermaid() {
            let needsLayout = false;

            mermaidContainers.forEach((item) => {
              if (item.rendered) return;

              const section = item.container.closest('section');
              if (section && (section.classList.contains('present') || section.closest('.present'))) {
                item.container.textContent = item.code;
                item.rendered = true;
                needsLayout = true;
              }
            });

            // Render all marked Mermaid diagrams
            const toRender = mermaidContainers.filter((item) => {
              return item.rendered && item.container.textContent;
            }).map((item) => item.container);

            if (toRender.length > 0) {
              try {
                await mermaid.run({ nodes: toRender });
                if (needsLayout) {
                  deck.layout();
                }
              } catch(e) {
                console.warn('Mermaid render warning:', e);
              }
            }
          }

          // Initial render with delay to ensure Reveal.js is fully initialized
          setTimeout(renderVisibleMermaid, 200);

          // Render on slide change
          deck.on('slidechanged', () => {
            setTimeout(renderVisibleMermaid, 50);
          });
        }

        // Initialize ECharts
        if (typeof (window as any).echarts !== 'undefined') {
          const echarts = (window as any).echarts;

          document.querySelectorAll('pre code.language-echarts, pre code.echarts').forEach((block, index) => {
            try {
              const code = (block.textContent || '').trim();
              const option = JSON.parse(code);

              // Create ECharts container
              const container = document.createElement('div');
              container.className = 'echarts-container';
              container.id = 'echarts-slide-' + index;
              container.style.height = '400px';
              container.style.width = '100%';

              // Replace code block
              const pre = block.parentElement;
              if (pre && pre.parentElement) {
                pre.parentElement.insertBefore(container, pre);
                pre.style.display = 'none';
              }

              echartsInstances.push({
                container: container,
                option: option,
                chart: null,
                initialized: false
              });
            } catch (e) {
              console.error('ECharts parsing error:', e);
            }
          });

          // Render visible ECharts
          function renderVisibleEcharts() {
            echartsInstances.forEach((item) => {
              const section = item.container.closest('section');
              const isVisible = section && (section.classList.contains('present') || section.closest('.present'));

              if (isVisible) {
                if (!item.initialized) {
                  item.chart = echarts.init(item.container);
                  item.chart.setOption(item.option);
                  item.initialized = true;
                } else if (item.chart) {
                  item.chart.resize();
                }
              }
            });
          }

          // Initial render
          setTimeout(renderVisibleEcharts, 100);

          // Render/resize on slide change
          deck.on('slidechanged', () => {
            setTimeout(renderVisibleEcharts, 50);
          });

          // Handle window resize
          window.addEventListener('resize', () => {
            echartsInstances.forEach((item) => {
              if (item.chart) {
                item.chart.resize();
              }
            });
          });
        }
      });
    </script>
  </body>
</html>
